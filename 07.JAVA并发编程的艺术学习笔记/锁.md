# 锁

锁从宏观上分类，分为悲观锁与乐观锁

## 线程安全问题

并不是多线程就一定会产生线程安全问题，只有当两个或多个线程对同一个资源进行非原子性操作时才会产生线程安全问题，对资源的访问顺序敏感就称存在竞态条件，导致竞态条件发生的代码区称作临界区

## 内置锁 互斥锁

每一个`JAVA`对象都可以用作一个实现同步的锁称为内置锁，线程进入同步代码块之前自动获取到锁，代码块执行完成正常退出或代码块中抛出异常退出时会释放掉锁。内置锁为互斥锁即线程`A`获取到锁后，线程`B`阻塞直到线程`A`释放锁，线程`B`才能获取到同一个锁。内置锁使用`synchronized`关键字实现

- 修饰普通方法，锁对象为调用同步方法的对象。俗称对象锁
- 修饰静态方法，锁对象为当前类`class`文件，俗称类锁
- 修饰代码块，锁对象为`synchronized()`中指定的对象

## 无锁 偏向锁 轻量级锁 重量级锁

四种状态会随着竞争的情况逐渐升级，并且是不可逆的过程。需要注意的是这四种状态都不是`JAVA`语言中的锁，而是`JVM`为了提高锁的获取与释放而做的优化(使用`synchronized`时)

- 偏向锁

  - 偏向锁的由来

    大多数情况下锁不存在多线程竞争而是总是由同一线程多次获得时，而线程的阻塞和唤醒需要`CPU`从用户态转为核心态，频繁的阻塞和唤醒对`CPU`来说是一件负担很重的工作，为了让线程获得锁的代价更低而引入了偏向锁，它通过消除资源无竞争情况下的同步原语提高了程序的运行性能

  - 偏向锁获取过程

    - 判断对象是否处于可偏向状态
    - 判断偏向锁对象头的`ThreadID`是否指向当前线程，如果是则执行同步代码
    - 如果偏向锁对象头的`ThreadID`并未指向当前线程则通过`CAS`操作竞争锁，如果竞争成功则将对象头的`ThreadID`设置为当前`ThreadID`然后执行执行同步代码，否则获取偏向锁失败则表示有竞争，当到达全局安全点时获得偏向锁的线程将被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码

  - 偏向锁的释放过程

    偏向锁只有遇到其他线程尝试竞争偏向锁时持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁

    - 暂停拥有偏向锁的线程，检查线程是否存活
    - 如果线程处于非活动状态，则设置为无锁状态
    - 如果线程仍然处于活跃状态则判断偏向锁线程是否处于同步代码块，若已退出同步代码块则恢复为无锁状态，若处于同步代码块则将锁升级为轻量级锁，最后唤醒原持有偏向锁的线程

  - 偏向锁适用场景

    始终只有一个线程在执行同步块，在它没有执行完释放锁之前没有其它线程去执行同步块。一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致`stop the word`操作导致性能下降，这种情况下应当禁用偏向锁优化。添加`VM`参数`-XX:-UseBiasedLocking`即可

- 轻量级锁

  - 轻量锁的由来

    轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁竞争的时候偏向锁就会升级为轻量级锁。轻量级锁的目标是减少无实际竞争情况下使用重量级锁产生的性能消耗

  - 轻量级锁获取过程

- 重量级锁

  其他线程试图获取锁时都会被阻塞，只有持有锁的线程释放锁之后才会唤醒这些线程进行竞争



|    锁    |                   优点                   |                     缺点                      |              适用场景              |
| :------: | :--------------------------------------: | :-------------------------------------------: | :--------------------------------: |
|  偏向锁  |        加锁和解锁不需要额外的消耗        |  如果线程间存在竞争会带来额外的锁撤销的消耗   |  适用于只有一个线程访问同步块场景  |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度 | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU | 追求响应时间，同步块执行速度非常快 |
| 重量级锁 |     线程竞争不适用自旋，不会消耗CPU      |            线程阻塞，响应时间缓慢             |   追求吞吐量，同步块执行时间较长   |

