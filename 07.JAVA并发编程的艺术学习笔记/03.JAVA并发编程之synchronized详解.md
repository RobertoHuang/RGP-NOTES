# `synchronized`详解

>  关于我:[http://huangth.com](http://huangth.com)
>
>  GitHub地址:[https://github.com/RobertoHuang](https://github.com/RobertoHuang)
>
>  参考资料
>
>  - [并发编程网](http://ifeve.com/)
>  - [参考博客 JAVA中的锁](https://blog.csdn.net/zqz_zqz/article/details/70233767)
>  - `JAVA`并发编程实战 - 书籍
>  - `JAVA`并发编程的艺术 - 书籍

## 对象头

`Mark Word`数据的长度在32位和64位的虚拟机(未开启压缩指针)中分别为32bit和64bit，它的最后2bit是锁状态标志位用来标记当前对象的状态，对象的所处的状态决定了`Mark Word`存储的内容

| 状态             | 标志位 | 存储内容                             |
| :--------------- | :----- | :----------------------------------- |
| 未锁定           | 01     | 对象哈希码、对象分代年龄             |
| 轻量级锁定       | 00     | 指向锁记录的指针                     |
| 膨胀(重量级锁定) | 10     | 执行重量级锁定的指针                 |
| GC标记           | 11     | 空(不需要记录信息)                   |
| 可偏向           | 01     | 偏向线程ID、偏向时间戳、对象分代年龄 |

32位虚拟机在不同状态下`Mark Word`结构如下图所示

![32位虚拟机在不同状态下Mark Word结构](https://raw.githubusercontent.com/RobertoHuang/RGP-NOTES/master/00.%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%89%87/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%8A%B6%E6%80%81%E4%B8%8BMark%20Word%E7%BB%93%E6%9E%84.png)

## 线程安全问题

并不是多线程就一定会产生线程安全问题，只有当两个或多个线程对同一个资源进行非原子性操作时才会产生线程安全问题，对资源的访问顺序敏感就称存在竞态条件，导致竞态条件发生的代码区称作临界区

## 内置锁 互斥锁 自旋锁

每一个`JAVA`对象都可以用作一个实现同步的锁称为内置锁，线程进入同步代码块之前自动获取到锁，代码块执行完成正常退出或代码块中抛出异常退出时会释放掉锁。内置锁为互斥锁即线程A获取到锁后，线程B阻塞直到线程A释放锁，线程B才能获取到同一个锁。内置锁使用`synchronized`关键字实现

![synchronized使用场景](https://raw.githubusercontent.com/RobertoHuang/RGP-NOTES/master/00.%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%89%87/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/synchronized%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.png)

自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等(自旋)，等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗

- 自旋锁的优点

  自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换

- 自旋锁的缺点

  如果锁的竞争激烈或者持有锁的线程需要长时间占用锁执行同步块这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用`CPU`做无用功，同时有大量线程在竞争一个锁会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要`CPU`的线程又不能获取到`CPU`造成`CPU`的浪费

## `synchronized`的`JVM`语义

`JVM`规范规定`JVM`基于进入和退出`Monitor`对象来实现方法同步和代码块同步，但两者的实现细节不一样

- 代码块同步是使用`monitorenter`和`monitorexit`指令实现
- 对于`synchronized`方法执行中的线程识别该方法的`method_info`结构是否有`ACC_SYNCHRONIZED`标记设置，然后它自动获取对象的锁、调用方法、最后释放锁，如果有异常发生线程自动释放锁

以下通过`javap -verbose`指令查看`synchronized`被编译成字节码后的执行计划

```java
public class TestSynchronized {
    public synchronized void test() {
        System.out.println("TEST SYNCHRONIZED");
    }

    public void test2() {
        synchronized (this) {
            System.out.println("TEST SYNCHRONIZED");
        }
    }
}
```

执行`javap -verbose TestSynchronized.class`

![synchronized的JVM语义](https://raw.githubusercontent.com/RobertoHuang/RGP-NOTES/master/00.%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%89%87/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/synchronized%E7%9A%84JVM%E8%AF%AD%E4%B9%89.png)

## 无锁 偏向锁 轻量级锁 重量级锁

使用`synchronized`时四种状态会随着竞争的情况逐渐升级并且是不可逆的过程，这种锁升级却不能降级的策略目的是为了提高获得锁和释放锁的效率。需要注意的是这四种状态都不是`JAVA`语言中的锁而是`JVM`为了提高锁的获取与释放而做的优化

- 偏向锁

  ![偏向锁](https://raw.githubusercontent.com/RobertoHuang/RGP-NOTES/master/00.%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%89%87/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%81%8F%E5%90%91%E9%94%81.png)

  - 偏向锁的由来

    大多数情况下锁不存在多线程竞争而是总是由同一线程多次获得时，而线程的阻塞和唤醒需要`CPU`从用户态转为核心态，频繁的阻塞和唤醒对`CPU`来说是一件负担很重的工作，为了让线程获得锁的代价更低而引入了偏向锁，它通过消除资源无竞争情况下的同步原语提高了程序的运行性能

  - 偏向锁获取过程

    - 判断对象是否处于可偏向状态
    - 判断偏向锁对象头的`ThreadID`是否指向当前线程，如果是则执行同步代码
    - 如果偏向锁对象头的`ThreadID`并未指向当前线程则通过`CAS`操作竞争锁，如果竞争成功则将对象头的`ThreadID`设置为当前`ThreadID`然后执行执行同步代码，否则获取偏向锁失败则表示有竞争，当到达全局安全点时获得偏向锁的线程将被挂起偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码

  - 偏向锁的释放过程

    偏向锁只有遇到其他线程尝试竞争偏向锁时持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁

    - 暂停拥有偏向锁的线程，检查线程是否存活
    - 如果线程处于非活动状态，则设置为无锁状态
    - 如果线程仍然处于活跃状态则判断偏向锁线程是否处于同步代码块，若已退出同步代码块则恢复为无锁状态，若处于同步代码块则将锁升级为轻量级锁，最后唤醒原持有偏向锁的线程

  - 偏向锁适用场景

    始终只有一个线程在执行同步块，在它没有执行完释放锁之前没有其它线程去执行同步块。一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致`stop the word`操作导致性能下降，这种情况下应禁用偏向锁优化。添加`VM`参数`-XX:-UseBiasedLocking=false`即可

- 轻量级锁

  ![轻量级锁](https://raw.githubusercontent.com/RobertoHuang/RGP-NOTES/master/00.%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%89%87/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png)

  - 轻量锁的由来

    轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁竞争的时候偏向锁就会升级为轻量级锁。轻量级锁的目标是减少无实际竞争情况下使用重量级锁产生的性能消耗

  - 轻量级锁获取过程

    - 在执行同步代码块前虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(`Lock Record`)的空间，用于存储锁对象目前的`Mark Word`的拷贝，官方称之为`Displaced Mark Word`。这时候线程堆栈与对象头的状态如图

      ![轻量级锁获取前线程堆栈与对象头](https://raw.githubusercontent.com/RobertoHuang/RGP-NOTES/master/00.%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%89%87/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E8%8E%B7%E5%8F%96%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4.jpg)

    - 拷贝对象头中的`Mark Word`复制到锁记录中

    - 拷贝成功后虚拟机将使用`CAS`操作尝试将对象的`Mark Word`更新为指向`Lock Record`的指针，并将`Lock record`里的`owner`指针指向对象的`Mark Word`。如果这个更新动作成功那么这个线程就拥有了该对象的锁，并且对象`Mark Word`的锁标志位设置为"00"此时线程堆栈与对象头的状态如下

      ![轻量级锁获取后线程堆栈与对象头](https://raw.githubusercontent.com/RobertoHuang/RGP-NOTES/master/00.%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%89%87/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E8%8E%B7%E5%8F%96%E5%90%8E%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4.jpg)

    - 如果这个更新操作失败了虚拟机首先会检查对象的`Mark Word`是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁那就可以直接进入同步块继续执行。否则当前线程便尝试使用自旋来获取锁(自旋就是为了不让线程阻塞，而采用循环去获取锁的过程)，如果自旋结束后仍未获取到锁就要膨胀为重量级锁，锁标志的状态值变为"10"，`Mark Word`中存储的就是指向重量级锁(互斥量)的指针，后面等待锁的线程也要进入阻塞状态

  - 轻量锁的释放

    轻量级锁释放的时候会使用`CAS`操作将`Displaced Mark Word`替换回对象头，如果它发现在它持有锁的期间有其他线程来尝试获取锁并且该线程对`Mark Word`做了修改，两者比对发现不一致则切换到重锁。以下是个人理解的偏向锁的释放和升级

    - A线程获取到了轻量级锁，B线程尝试获取锁失败则自旋获取锁，如果B线程自旋过程中A线程释放了锁，则B线程获取到轻量级锁。此时锁仍为轻量级锁
    - A线程获取到了轻量级锁，B线程尝试获取锁失败则自旋获取锁，如果B线程自旋结束后A线程仍占有锁则B线程将修改锁对象的`Mark Word`升级为重量级锁，此时A线程执行完同步代码块后尝试`CAS`方式释放锁，但是锁对象的`Mark Word`已经被B线程修改所以`CAS`替换失败，此时A线程将升级为重量级锁，即将锁对象的`Mark Word`中锁标志位改成"10"

- 重量级锁

  其他线程试图获取锁时都会被阻塞，只有持有锁的线程释放锁之后才会唤醒这些线程进行竞争

## `synchronized`的执行过程与总结

`synchronized`执行过程如下

- 检测`Mark Word`里面是不是当前线程的ID，如果是表示当前线程处于偏向锁
- 如果不是则使用`CAS`将当前线程ID替换`Mard Word`，如果成功则表示当前线程获得偏向锁置偏向标志位"1"
- 如果失败则说明发生竞争，撤销偏向锁进而升级为轻量级锁
- 当前线程使用`CAS`将对象头的`Mark Word`替换为锁记录指针，如果成功当前线程获得锁
- 如果失败表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁
- 如果自旋成功则依然处于轻量级状态
- 如果自旋失败，则升级为重量级锁

|    锁    |                   优点                   |                     缺点                      |              适用场景              |
| :------: | :--------------------------------------: | :-------------------------------------------: | :--------------------------------: |
|  偏向锁  |        加锁和解锁不需要额外的消耗        |  如果线程间存在竞争会带来额外的锁撤销的消耗   |  适用于只有一个线程访问同步块场景  |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度 | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU | 追求响应时间，同步块执行速度非常快 |
| 重量级锁 |     线程竞争不适用自旋，不会消耗CPU      |            线程阻塞，响应时间缓慢             |   追求吞吐量，同步块执行时间较长   |

## `synchronized`与单例模式

```java
public class Singleton {
    private static volatile Singleton instance;

    public static Singleton getInstance () {
        if(instance == null) {
            synchronized (Singleton.class) {
                if(instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

