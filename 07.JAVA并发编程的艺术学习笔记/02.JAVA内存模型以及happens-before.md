# `JMM`介绍

![JMM内存结构抽象结构示意图](https://raw.githubusercontent.com/RobertoHuang/RGP-NOTES/master/00.%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%89%87/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JMM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E6%8A%BD%E8%B1%A1%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

`CPU`的处理速度和主存的读写速度不是一个量级的，为了平衡这种巨大的差距每个`CPU`都会有缓存。因此共享变量会先放在主存中，每个线程都有属于自己的工作内存，并且会把位于主存中的共享变量拷贝到自己的工作内存，之后的读写操作均使用位于工作内存的变量副本，并在某个时刻将工作内存的变量副本写回到主存中去【出现线程安全的问题一般是因为**主内存和工作内存数据不一致性**和**重排序**导致的】

- 内存模型抽象结构

  > 线程间协作通信可以类比人与人之间的协作的方式，在现实生活中网上有个流行语"你妈喊你回家吃饭了"。小明在外面玩耍小明妈妈在家里做饭，做晚饭后准备叫小明回家吃饭，那么就存在两种方式：
  >
  > 小明妈妈要去上班了十分紧急这个时候手机又没有电了，于是就在桌子上贴了一张纸条"饭做好了，放在..."，小明回家后看到纸条如愿吃到妈妈做的饭菜，如果将小明妈妈和小明作为两个线程，那么这张纸条就是这两个线程间通信的共享变量，通过读写**共享变量**实现两个线程间协作
  >
  > 妈妈的手机还有电，妈妈在赶去坐公交的路上给小明打了个电话，这种方式就是**通知机制**来完成协作

- 

