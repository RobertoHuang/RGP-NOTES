# `JMM`介绍

关于我:[http://huangth.com](http://huangth.com)

GitHub地址:[https://github.com/RobertoHuang](https://github.com/RobertoHuang)

参考资料

- [并发编程网](http://ifeve.com/)
- `JAVA`并发编程实战 - 书籍
- `JAVA`并发编程的艺术 - 书籍

> 线程间协作通信可以类比人与人之间的协作的方式，在现实生活中网上有个流行语"你妈喊你回家吃饭了"。小明在外面玩耍小明妈妈在家里做饭，做晚饭后准备叫小明回家吃饭，那么就存在两种方式：
>
> 小明妈妈要去上班了十分紧急这个时候手机又没有电了，于是就在桌子上贴了一张纸条"饭做好了，放在..."，小明回家后看到纸条如愿吃到妈妈做的饭菜，如果将小明妈妈和小明作为两个线程，那么这张纸条就是这两个线程间通信的共享变量，通过读写**共享变量**实现两个线程间协作
>
> 妈妈的手机还有电，妈妈在赶去坐公交的路上给小明打了个电话，这种方式就是**通知机制**来完成协作

![JMM内存结构抽象结构示意图](https://raw.githubusercontent.com/RobertoHuang/RGP-NOTES/master/00.%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%89%87/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/JMM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E6%8A%BD%E8%B1%A1%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

- `JMM`抽象结构模型

  `CPU`的处理速度和主存的读写速度不是一个量级的，为了平衡这种巨大的差距每个`CPU`都会有缓存。因此共享变量会先放在主存中，每个线程都有属于自己的工作内存，并且会把位于主存中的共享变量拷贝到自己的工作内存，之后的读写操作均使用位于工作内存的变量副本，并在某个时刻将工作内存的变量副本写回到主存中去【出现线程安全的问题一般是因为**主内存和工作内存数据不一致性**和**重排序**导致的】

- 指令重排序【编译器和处理器】

  为了提高性能，编译器和处理器常常会对指令进行重排序，一般重排序可以分为如下三种：

  ![从源码到最终执行的指令序列的示意图](https://raw.githubusercontent.com/RobertoHuang/RGP-NOTES/master/00.%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%89%87/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E6%9C%80%E7%BB%88%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

  编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序【1. 读后写；2.写后写；3. 写后读】

  > as-if-serial：不管怎么重排序(编译器和处理器为了提供并行度)，(单线程)程序的执行结果不能被改变

- `happens-before`规则

  - 程序顺序规则 - `一个线程中的每个操作，happens-before于该线程中的任意后续操作`
  - `volatile`变量规则 - `对一个volatile域的写，happens-before于任意后续对这个volatile域的读`
  - 监视器锁规则 - `对一个锁的解锁，happens-before于随后对这个锁的加锁`
  - 传递性 - `如果A happens-before B，且B happens-before C，那么A happens-before C`
  - `start()/join()`规则 - `如果线程A执行ThreadB.start()，那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。如果线程A执行ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回`
  - 程序中断规则 - `对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生`
  - 对象`finalize`规则 - `一个对象的初始化完成(构造函数执行结束)先行于发生它的finalize()方法的开始`

  注意:`JMM`可以通过`happens-before`关系向程序员提供跨线程的内存可见性保证。如果`A happens-before B`，`JMM`并不要求A一定要在B之前执行。`JMM`仅仅要求前一个操作(执行的结果)对后一个操作可见，且前一个操作按顺序排在第二个操作之前。【如果操作A的执行结果不需要对操作B可见，并且重排序操作A和操作B后的执行结果与操作A和操作B按`happens-before`顺序执行的结果一直，在这种情况下`JMM`会认为这种重排序并不非法，即`JMM`允许这种重排序】