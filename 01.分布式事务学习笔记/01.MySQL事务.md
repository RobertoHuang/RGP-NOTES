# MySQL事务

- 事务基本要素(ACID)

  ```reStructuredText
  1.原子性(Atomicity):事务开始后所有操作要么全部做完要么全部不做
  2.一致性(Consistency):事务开始前和结束后，数据库的完整性约束没有被破坏
  3.隔离性(Isolation):同一时间只允许一个事务请求同一个数据，不同事务之间彼此没有任何干扰
  4.持久性(Durability):事务完成后事务对数据的所有更新将被保存到数据库，不能进行回滚
  ```

- 事务的并发问题

  ```reStructuredText
  1、脏读:事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
  2、不可重复读:事务A多次读取同一数据，事务B在事务A多次读取的过程中对数据作了更新并提交，导致事务A多次读取同一数据时结果不一致
  3、幻读:系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样这就叫幻读【即幻读为在事务中无法感知到其他客户端的新增/删除操作】
  
  小结:不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表
  ```

- 事务隔离级别

  |        事务隔离级别        | 脏读 | 不可重复读 | 幻读 |
  | :------------------------: | :--: | :--------: | :--: |
  | 读未提交(read-uncommitted) |  是  |     是     |  是  |
  | 不可重复读(read-committed) |  否  |     是     |  是  |
  | 可重复读(repeatable-read)  |  否  |     否     |  是  |
  |    串行化(serializable)    |  否  |     否     |  否  |

- 实验证明(经典转账案例)

  -  读未提交(read-uncommitted)

    ```sql
    1.设置事务隔离级别:
    	# 系统级别
    	set global transaction isolation level read uncommitted;
    	# 会话级别
    	set session transaction isolation level read uncommitted;
    2.A:开启事务 查询张三账户余额450
      B:开启事务 更新张三账户余额为400
      A:查询张三账户余额为400
      B:回滚事务
      A:查询张三账户余额为450
    3.总结:在客户端A中查询到客户端B事务未提交的数据 即出现了脏读的现象
    ```

  - 读已提交 (read-committed)

    ```reStructuredText
    1.设置事务隔离级别:
    	# 系统级别
    	set global transaction isolation level read committed;
    	# 会话级别
    	set session transaction isolation level read committed;
    2.A:开启事务 查询张三账户余额450
      B:开启事务 更新张三账户余额400
      A:查询张三账户 余额仍为450
      B:事务提交
      A:查询张三账户 余额变为400
    3.总结:在客户端A事务中执行多次查询，尝试的结果不一致。即出现了不可重复读的现象
    ```

  - 可重复读(repeatable-read)  **默认事务隔离级别**

    ```reStructuredText
    1.设置事务隔离级别:
    	# 系统级别
    	set global transaction isolation level repeatable read;
    	# 会话级别
    	set session transaction isolation level repeatable read;
    2.A:开启事务 查询张三账户余额450
      B:开启事务 更新张三账户余额400
      A:查询张三账户 余额仍为450
      B:事务提交
      A:查询张三账户 余额仍为450 更新张三账户-50元 => 350元【保证了数据一致性】
      B:客户端B开启事务 插入一条数据 提交事务
      A:计算余额总和时，不能将B客户端新增的数据计算在内，提交事务后重新计算才能将B客户端新增的数据纳入
    3.总结:站在客户的角度客户是看不到客户端B的，它会觉得是天下掉馅饼了。在事务提交后计算余额变多了，这就是幻读
    ```

  - 串行化(serializable) 

    ```reStructuredText
    使用串行化可避免以上现象的发生，但是MySQL中事务隔离级别为serializable时会锁表，因此极少使用
    ```

- 相关命令

  ```sql
  -- 开启事务
  start transaction;
  
  -- 提交事务
  commit;
  
  -- 回滚事务
  rollback;
  ```