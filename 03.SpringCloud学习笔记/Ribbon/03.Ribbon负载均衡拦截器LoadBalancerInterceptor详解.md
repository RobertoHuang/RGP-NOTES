## `RestTemplate`拦截器机制

从上一篇博客中我们可以知道在声明`RestTemplate`时如果添加了`@LoadBalanced`注解的话，会往其拦截器链上添加一个`LoadBalancerInterceptor`拦截器，接下来我们看一下`LoadBalancerInterceptor`是如何起作用的

- 在使用`RestTemplate`发送请求时会执行`doExecute`方法

  ```java
  protected <T> T doExecute(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback, @Nullable ResponseExtractor<T> responseExtractor) throws RestClientException {
      // ...
      ClientHttpRequest request = createRequest(url, method);
      ClientHttpResponse response = request.execute();
      handleResponse(url, method, response);
      return (responseExtractor != null ? responseExtractor.extractData(response) : null);
  }
  ```

  省去健壮性分支代码后，它主要的功能为创建`ClientHttpRequest`并执行`execute`方法，处理结果并返回

  - 创建`ClientHttpRequest`，如果`RestTemplate`中有拦截器，返回`InterceptingClientHttpRequest`

  - 执行`execute`方法，跟踪调用链将调用`InterceptingRequestExecution`的`execute`方法，源码如下

    ```java
    public ClientHttpResponse execute(HttpRequest request, byte[] body) throws IOException {
        if (this.iterator.hasNext()) {
            ClientHttpRequestInterceptor nextInterceptor = this.iterator.next();
            return nextInterceptor.intercept(request, body, this);
        } else {
            // 调用SimpleBufferingClientHttpRequest.execute()执行请求... 
            ClientHttpRequest delegate = requestFactory.createRequest(request.getURI(), method);
            return delegate.execute();
        }
    }
    ```

    - 遍历拦截器链调用拦截器`intercept`方法

    - 当通过所有拦截器后调用`SimpleBufferingClientHttpRequest`的`execute`方法执行请求


## `LoadBalancerInterceptor`详解

- `LoadBalancerInterceptor`对请求拦截的源代码如下

  ```java
  @Override
  public ClientHttpResponse intercept(final HttpRequest request, final byte[] body, final ClientHttpRequestExecution execution) throws IOException {
      final URI originalUri = request.getURI();
      String serviceName = originalUri.getHost();
      Assert.state(serviceName != null, "Request URI does not contain a valid hostname: " + originalUri);
      return this.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));
  }
  ```

  其核心是调用了`loadBalancer`的`execute`方法，`loadBalancer`是在`LoadBalancerInterceptor`构造方法中传入的，如果不额外声明默认为`RibbonLoadBalancerClient`，该配置在`RibbonAutoConfiguration`

  ```java
  @Bean
  @ConditionalOnMissingBean(LoadBalancerClient.class)
  public LoadBalancerClient loadBalancerClient() {
      return new RibbonLoadBalancerClient(springClientFactory());
  }    
  ```

- `LoadBalancerClient`表示一个客户端负载均衡器，它继承了`ServiceInstanceChooser`

    ```java
    public interface ServiceInstanceChooser {
        // 根据serviceId选择要执行请求的实例
        ServiceInstance choose(String serviceId);
    }
    
    public interface LoadBalancerClient extends ServiceInstanceChooser {
        // 使用从负载均衡器中挑选出的服务实例来执行请求内容
        <T> T execute(String serviceId, LoadBalancerRequest<T> request) throws IOException;
        
        // 使用指定实例在执行请求内容
        <T> T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest<T> request) throws IOException;
    
        // 构建请求URI
        URI reconstructURI(ServiceInstance instance, URI original);
    }
    ```

- 接下来跟进`RibbonLoadBalancerClient`的`execute`方法，源代码如下

  ```java
  public <T> T execute(String serviceId, LoadBalancerRequest<T> request) throws IOException {
      ILoadBalancer loadBalancer = getLoadBalancer(serviceId);
      Server server = getServer(loadBalancer);
      if (server == null) {
          throw new IllegalStateException("No instances available for " + serviceId);
      }
      RibbonServer ribbonServer = new RibbonServer(serviceId, server, isSecure(server, serviceId), serverIntrospector(serviceId).getMetadata(server));
      return execute(serviceId, ribbonServer, request);
  }
  ```

  - 根据`serviceId`获取对应`ILoadBalancer`实例
  - 使用`ILoadBalancer`选出用来执行请求的服务实例
  - 将`Server`实例封装成`RibbonServer`即`ServiceInstance`实例，执行请求

- `ILoadBalancer`接口定义了负载均衡的一些操作，`RibbonLoadBalancerClient`的负载即通过它实现的

    ```java
    public interface ILoadBalancer {
        // 向负载均衡器中维护的实例列表增加服务实例
        public void addServers(List<Server> newServers);
    
        // 从负载均衡器中挑选出一个具体的服务实例
        public Server chooseServer(Object key);
        
        // 用来通知和标识负载均衡器中某个具体实例已经停止服务
        public void markServerDown(Server server);
        
        // 获取当前正常服务的实例列表
        public List<Server> getReachableServers();
    
        // 获取所有已知的服务实例列表，包括正常服务和停止服务的实例
        public List<Server> getAllServers();
    }
    ```

    如果不进行额外配置的话，`Spring Cloud`默认的`ILoadBalancer`实现为`ZoneAwareLoadBalancer`

    ```java
    @Bean
    @ConditionalOnMissingBean
    public ILoadBalancer ribbonLoadBalancer(IClientConfig config, ServerList<Server> serverList, ServerListFilter<Server> serverListFilter, IRule rule, IPing ping, ServerListUpdater serverListUpdater) {
        if (this.propertiesFactory.isSet(ILoadBalancer.class, name)) {
            return this.propertiesFactory.get(ILoadBalancer.class, config, name);
        }
        return new ZoneAwareLoadBalancer<>(config, rule, ping, serverList, serverListFilter, serverListUpdater);
    }
    ```

- `ServiceInstance`用户描述实例的属性

    ```java
    public interface ServiceInstance {
        String getServiceId();
    
        String getHost();
    
        int getPort();
    
        boolean isSecure();
    
        URI getUri();
    
        Map<String, String> getMetadata();
    
        default String getScheme() {
            return null;
        }
    }
    ```

- 将`ServeceId`封装成`RibbonServer`后，调用`excute`方法

    ```java
    public <T> T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest<T> request) throws IOException {
        T returnVal = request.apply(serviceInstance);
        return returnVal;
    }
    ```

    去掉一些健壮性分支的代码，`execute`方法主要完成的功能就是调用`request.apply(serviceInstance)`

    ```java
    HttpRequest serviceRequest = new ServiceRequestWrapper(request, instance, loadBalancer);
    if (transformers != null) {
        for (LoadBalancerRequestTransformer transformer : transformers) {
            serviceRequest = transformer.transformRequest(serviceRequest, instance);
        }
    }
    return execution.execute(serviceRequest, body);
    ```

    该部分代码在`LoadBalancerRequestFactory`的匿名类中，作用是将请求封装成`ServiceRequestWrapper`

- `ServiceRequestWrapper`对象，该对象继承了`HttpRequestWrapper`并重写了`getURI`函数，重写后的`getURI`会通过调用`LoadBalancerClient`接口的`reconstructURI`函数来重新构建一个`URI`来进行访问

    ```java
    public URI getURI() {
        URI uri = this.loadBalancer.reconstructURI(this.instance, getRequest().getURI());
        return uri;
    }
    ```

    现在回头看`InterceptingRequestExecution`的`execute`方法，当走完过滤器链的时候将调用`getURI`方法

- `ServiceRequestWrapper`的`getURI`主要是调用了`LoadBalancerClient`的`reconstructURI`方法

    ```java
    public URI reconstructURI(ServiceInstance instance, URI original) {
        String serviceId = instance.getServiceId();
        RibbonLoadBalancerContext context = this.clientFactory.getLoadBalancerContext(serviceId);
    
        URI uri;
        Server server;
        if (instance instanceof RibbonServer) {
            RibbonServer ribbonServer = (RibbonServer) instance;
            server = ribbonServer.getServer();
            uri = updateToSecureConnectionIfNeeded(original, ribbonServer);
        } else {
            server = new Server(instance.getScheme(), instance.getHost(), instance.getPort());
            IClientConfig clientConfig = clientFactory.getClientConfig(serviceId);
            ServerIntrospector serverIntrospector = serverIntrospector(serviceId);
            uri = updateToSecureConnectionIfNeeded(original, clientConfig, serverIntrospector, server);
        }
        return context.reconstructURIWithServer(server, uri);
    }
    ```

    - 根据`serviceId`获取`RibbonLoadBalancerContext`对象

    - 使用`RibbonLoadBalancerContext`对象的`reconstructURIWithServer`函数来构建服务实例的URI

      ```java
      public URI reconstructURIWithServer(Server server, URI original) {
          String host = server.getHost();
          int port = server .getPort();
          if (host.equals(original.getHost())
                  && port == original.getPort()) {
              return original;
          }
          String scheme = original.getScheme();
          if (scheme == null) {
              scheme = deriveSchemeAndPortFromPartialUri(original).first();
          }
      
          try {
              StringBuilder sb = new StringBuilder();
              sb.append(scheme).append("://");
              if (!Strings.isNullOrEmpty(original.getRawUserInfo())) {
                  sb.append(original.getRawUserInfo()).append("@");
              }
              sb.append(host);
              if (port >= 0) {
                  sb.append(":").append(port);
              }
              sb.append(original.getRawPath());
              if (!Strings.isNullOrEmpty(original.getRawQuery())) {
                  sb.append("?").append(original.getRawQuery());
              }
              if (!Strings.isNullOrEmpty(original.getRawFragment())) {
                  sb.append("#").append(original.getRawFragment());
              }
              URI newURI = new URI(sb.toString());
              return newURI;
          } catch (URISyntaxException e) {
              throw new RuntimeException(e);
          }
      }
      ```

      从`reconstructURIWithServer`的实现逻辑中，我们可以看到它从`Server`对象中获取`hos`和`port`信息，然后根据以服务名为`host`的`URI`对象`original`中获取其他请求信息，将两者内容进行拼接整合，形成最终要访问的服务实例的具体地址

- 到这里我们已经可以大致理清`Spring Cloud`中使用`Ribbon`实现客户端负载均衡的基本脉络，了解了它是如何通过`LoadBalancerInterceptor`拦截器对`RestTemplate`的请求进行拦截，并利用`Spring Cloud`的负载均衡器`LoadBalancerClient`将以逻辑服务名为`Host`的`URI`转换成具体的服务实例的过程。同时通过分析`LoadBalancerClient`的`Ribbon`实现`RibbonLoadBalancerClient`，可以知道在使用`Ribbon`实现负载均衡器的时候，实际使用的还是`Ribbon`中定义的`ILoadBalancer`接口的实现，自动化配置会采用`ZoneAwareLoadBalancer`的实例来进行客户端负载均衡实现