# ILoadBalancer

在上一篇博客中介绍到`Ribbon`使用`ILoadBalancer`接口选出用来执行请求的服务实例，本博客将详细介绍该接口实现类逐个看看它都是如何实现客户端负载均衡的

## AbstractLoadBalancer

`AbstractLoadBalancer`是`ILoadBalancer`的抽象实现类

```java
public abstract class AbstractLoadBalancer implements ILoadBalancer {
    public enum ServerGroup{
        ALL,
        STATUS_UP,
        STATUS_NOT_UP        
    }
        
    public Server chooseServer() {
    	return chooseServer(null);
    }

    public abstract List<Server> getServerList(ServerGroup serverGroup);
    
    public abstract LoadBalancerStats getLoadBalancerStats();    
}
```

在该抽象类中定义了一个关于服务实例的分组枚举类`ServerGroup`，它包含了三种不同类型`ALL所有服务实例`、`STATUS_UP正常服务的实例`、`STATUS_NOT_UP停止服务的实例`。定义了两个抽象函数

- `getServerList(ServerGroup serverGroup)`定义了根据分组类型来获取不同的服务实例列表
- `getLoadBalancerStats()`定义了获取`LoadBalancerStats`对象的方法，`LoadBalancerStats`对象被用来存储负载均衡器中各个服务实例当前的属性和统计信息。我们可以利用这些信息来观察负载均衡器的运行情况，同时这些信息也是用来制定负载均衡策略的重要依据

## BaseLoadBalancer

`BaseLoadBalancer`类是Ribbon负载均衡器的基础实现类，在该类中定义很多关于均衡负载器相关的基础内容

- 定义并维护了两个存储服务实例`Server`对象的列表，分别为所有服务实例清单，正常服务实例清单

  ```java
  @Monitor(name = PREFIX + "AllServerList", type = DataSourceType.INFORMATIONAL)
  protected volatile List<Server> allServerList = Collections.synchronizedList(new ArrayList<Server>());
  
  @Monitor(name = PREFIX + "UpServerList", type = DataSourceType.INFORMATIONAL)
  protected volatile List<Server> upServerList = Collections.synchronizedList(new ArrayList<Server>());
  ```

- 定义了之前我们提到的用来存储负载均衡器各服务实例属性和统计信息的`LoadBalancerStats`对象

- 定义了检查服务实例是否正常的`IPing`对象，默认为`Null`需要在构造时注入它的具体实现

- 定义了检查服务实例操作的执行策略对象`IPingStrategy`，默认实现为`SerialPingStrategy`

  ```java
  public boolean[] pingServers(IPing ping, Server[] servers) {
          int numCandidates = servers.length;
          boolean[] results = new boolean[numCandidates];
  
          for (int i = 0; i < numCandidates; i++) {
              results[i] = false;
              try {
                  if (ping != null) {
                      results[i] = ping.isAlive(servers[i]);
                  }
              } catch (Exception e) {
                  logger.error("Exception while pinging Server: '{}'", servers[i], e);
              }
          }
          return results;
      }
  }
  ```

  该策略采用线性遍历`ping`服务实例的方式实现检查。该策略在当我们实现的`IPing`速度不理想或是`Server`列表过大时可能变的不是很为理想，这时候我们需要通过实现`IPingStrategy`接口并实现`pingServers`方法去扩展`ping`的执行策略

- 定义了负载均衡的处理规则`IRule`对象，负载均衡器实际进行服务实例选择任务是委托给了`IRule`实例

|     车场名称     | 在场车位数 | 总车位数 | 负载率 |
| :--------------: | :--------: | :------: | :----: |
| 广州万科云城一期 |    156     |   438    | 35.61% |
| 广州基盛中央公园 |    230     |   600    | 38.33% |
|  广州喜龙车博园  |     49     |   200    | 24.50% |
|  广州泊寓科学城  |     64     |    40    |  160%  |
| 广州天河创想公社 |     33     |    80    | 41.25% |

