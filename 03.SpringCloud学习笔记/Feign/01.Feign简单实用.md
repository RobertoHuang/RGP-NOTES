# Feign使用

- `pom.xml`配置

  ```xml
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-openfeign</artifactId>
  </dependency>
  ```

- 启动类添加`@EnableFeignClients`注解

- 使用`@FeignClient`注解定义`FeignClient`客户端

  ```java
  @FeignClient(value = "auth-service")
  public interface AuthServiceFeignClient {
      @PostMapping(value = "/oauth/token")
      String getToken(@RequestHeader(value = "Authorization") String authorization, @RequestParam("grant_type") String type, @RequestParam("username") String username, @RequestParam("password") String password);
  }
  ```

## 日志配置

- 项目日志配置

- `Feign`日志配置

  ```java
  @Bean
  public Logger.Level feignLoggerLevel() {
      return Logger.Level.FULL;
  }
  
  NONE:不记录任何信息
  BASIC:仅记录请求方法、URL以及响应状态码和执行时间
  HEADERS:除了记录BASIC级别的信息外，还会记录请求和响应的头信息
  FULL:记录所有请求与响应的明细，包括头信息，请求体，元数据
  ```

## 服务降级

```yaml
feign:
  hystrix:
    enabled: true
```

## 超时配置

- `Ribbon超时配置` 【`feign.RetryableException: Read timed out executing`】

  ```yaml
  ribbon:
    ReadTimeout: 60000
    ConnectTimeout: 3000
  ```

- `Hystrix`超时配置 【`com.netflix.hystrix.exception.HystrixRuntimeException:  timed-out`】

  ```yaml
  hystrix:
    command:
      default:
        circuitBreaker:
          # 短路多久后开始尝试是否恢复
          sleepWindowInMilliseconds: 1000
        execution:
          isolation:
            thread:
              # 命令执行超时时间 默认1000ms
              timeoutInMilliseconds: 6000
  ```

## 文件上传

- 文件上传客户端

  - `pom.xml`配置

    ```xml
    <dependency>
        <groupId>io.github.openfeign.form</groupId>
        <artifactId>feign-form</artifactId>
        <version>3.0.3</version>
    </dependency>
    ```

  - `FeignClient配置`

    ```java
    @Configuration
    public class FeignMultipartSupportConfig {
        @Bean
        @Primary
        @Scope("prototype")
        public Encoder multipartFormEncoder() {
            return new SpringFormEncoder();
        }
    }
    ```

  - `FeignClient`声明

    ```java
    @FeignClient(value = "feign-file-server", configuration = FeignMultipartSupportConfig.class)
    public interface FileUploadFeignService {
        @RequestMapping(method = RequestMethod.POST, value = "/uploadFile/server", produces = {MediaType.APPLICATION_JSON_UTF8_VALUE}, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
        String fileUpload(@RequestPart(value = "file") MultipartFile file);
    }
    ```

    - `produces`，`consumes`必填
    - 注意区分`@RequestPart`和`@RequestParam`，此处为`@RequestPart(value = "file")` 

- 文件上传服务端

  ```java
  @RestController
  public class FeignUploadController {
      @PostMapping(value = "/uploadFile/server", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
      public String fileUploadServer(MultipartFile file) throws Exception {
          return file.getOriginalFilename();
      }
  }
  ```

## GZIP压缩配置

```yaml
feign:
  compression:
    request:
      enabled: true
      # 配置压缩支持的类型
      mime-types: text/xml,application/xml,application/json
      # 配置压缩数据大小的下限
      min-request-size: 2048
    response:
      # 配置响应GZIP压缩
      enabled: true
```

由于开启`GZIP`压缩后`Feign`之间的调用开启二进制协议进行传输，返回值需修改为`ResponseEntity<byte[]>`才可以正常显示，否则会导致服务之间的调用结果乱码，示例代码如下

```java
@RequestMapping(value = "/findUser", method = RequestMethod.GET)
ResponseEntity<String> findUser(@RequestParam("username") String username);
```

## 替换默认`Client`

### `OkHttpClient`

- 导入依赖

  ```xml
  <dependency>
      <groupId>io.github.openfeign</groupId>
      <artifactId>feign-okhttp</artifactId>
  </dependency>
  ```

- `YAML`配置

  ```yaml
  feign:
    httpclient:
      enabled: false
    okhttp:
      enabled: true
  ```

- `OkHttpClient配置`

  ```java
  @Configuration
  @ConditionalOnClass(Feign.class)
  @AutoConfigureBefore(FeignAutoConfiguration.class)
  public class FeignOkHttpConfig {
      @Bean
      public okhttp3.OkHttpClient okHttpClient() {
          return new okhttp3.OkHttpClient.Builder()
                  // 设置读超时
                  .readTimeout(60, TimeUnit.SECONDS)
                  // 设置写超时
                  .writeTimeout(60, TimeUnit.SECONDS)
                  // 设置连接超时
                  .connectTimeout(60, TimeUnit.SECONDS)
                  // 是否自动重连
                  .retryOnConnectionFailure(true)
                  .connectionPool(new ConnectionPool()).build();
      }
  }
  ```

### `Apache HttpClient`

- 导入依赖

  ```xml
  <dependency>
      <groupId>org.apache.httpcomponents</groupId>
      <artifactId>httpclient</artifactId>
  </dependency>
  
  <dependency>
      <groupId>com.netflix.feign</groupId>
      <artifactId>feign-httpclient</artifactId>
      <version>8.17.0</version>
  </dependency>
  ```

- `YAML`配置

  ```yaml
  feign:
    httpclient:
      enabled: true
  ```

## `Get`请求多参数传递

- 配置`RequestInterceptor` 并纳入`Spring`管理

  ```java
  @Component
  public class FeignRequestInterceptor implements RequestInterceptor {
      @Autowired
      private ObjectMapper objectMapper;
  
      @Override
      public void apply(RequestTemplate template) {
          // feign 不支持 GET 方法传 POJO, json body转query
          if (template.method().equals("GET") && template.body() != null) {
              try {
                  JsonNode jsonNode = objectMapper.readTree(template.body());
                  template.body(null);
  
                  Map<String, Collection<String>> queries = new HashMap<>();
                  buildQuery(jsonNode, "", queries);
                  template.queries(queries);
              } catch (Exception e) {
                  // 提示:根据实践项目情况处理此处异常，这里不做扩展
                  e.printStackTrace();
              }
          }
      }
  
      private void buildQuery(JsonNode jsonNode, String path, Map<String, Collection<String>> queries) {
          // 叶子节点
          if (!jsonNode.isContainerNode()) {
              if (jsonNode.isNull()) {
                  return;
              }
              Collection<String> values = queries.get(path);
              if (null == values) {
                  values = new ArrayList<>();
                  queries.put(path, values);
              }
              values.add(jsonNode.asText());
              return;
          }
          // 数组节点
          if (jsonNode.isArray()) {
              Iterator<JsonNode> it = jsonNode.elements();
              while (it.hasNext()) {
                  buildQuery(it.next(), path, queries);
              }
          } else {
              Iterator<Map.Entry<String, JsonNode>> it = jsonNode.fields();
              while (it.hasNext()) {
                  Map.Entry<String, JsonNode> entry = it.next();
                  if (StringUtils.hasText(path)) {
                      buildQuery(entry.getValue(), path + "." + entry.getKey(), queries);
                  } else {
                      // 根节点
                      buildQuery(entry.getValue(), entry.getKey(), queries);
                  }
              }
          }
      }
  }
  ```