# Hystrix使用

> 关于我:[http://huangth.com](http://huangth.com)
> 
> GitHub地址:[https://github.com/RobertoHuang](https://github.com/RobertoHuang)
> 
> 参考资料

- `pom.xml`配置

  ```xml
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
  </dependency>
  ```

- 启动类添加`@EnableHystrix`注解

- 方法添加`@HystrixCommand(fallbackMethod = "testFallback")`，并创建`testFallBack`方法

  ```java
  public String testFallback() {
      return "服务器忙 请稍后重试";
  }
  ```

## 整合`Feign`

- `YML`添加配置

  ```yaml
  feign:
    hystrix:
      enabled: true  
  ```

- `@FeignClient`注解中添加`fallback`属性

  ```java
  @FeignClient(value = "auth-service",fallback = AuthServiceFeignClientFallBack.class)
  ```

- 新建`AuthServiceFeignClientFallBack`类

  ```java
  @Component
  public class AuthServiceFeignClientFallBack implements AuthServiceFeignClient{
      @Override
      public String getToken(String authorization, String type, String username, String password) {
          return "xxx";
      }
  }
  ```

## `Hystrix Dashboard`

- 监控客户端配置

  - `pom.xml`配置

    ```xml
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
    ```

  - 暴露`/actuator/hystrix.stream`端点

    ```yaml
    feign:
      hystrix:
        enabled: true
        
    management:
      security:
        enabled: false
      endpoints:
        web:
          exposure:
            include: hystrix.stream
    ```

- 监控服务端配置

  - `pom.xml`配置

    ```xml
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>
    </dependency>
    ```

  - 启动类添加注解`@EnableHystrixDashboard`

  - 访问`/hystrix`端点，填入要监控的地址。界面上有三个地址分别是三种监控方式

    - 默认集群监控:`http://turbine-hostname:port/turbine.stream`
    - 指定集群监控:`http://turbine-hostname:port/turbine.stream?cluster=[clusterName]`
    - 单个应用监控:`http://hystrix-app:port/hystrix.stream`

  - 仪表盘参数说明

    - 圆圈代表流量的大小和流量的健康，有绿色、黄色、橙色、红色
    - 曲线表示两分钟内流量的变化，圆圈右边的数字从上到下从左到右分别代表了请求的成功、熔断数、错误的请求、超时的请求、线程池拒绝数、失败的请求、和最近10S内错误的比率


## `Turbine`聚合`Hystrix`

- `pom.xml`配置

  ```xml
  <dependency>
  	<groupId>org.springframework.cloud</groupId>
  	<artifactId>spring-cloud-starter-netflix-turbine</artifactId>
  </dependency>
  ```

- 启动类添加`@EnableTurbine`注解

- `YML`添加`turbine`配置

  ```yaml
  turbine:
    appConfig: user-center-service
    clusterNameExpression: "'default'"
  ```

- 访问`/hystrix`端点，填入要监控的地址。此时输入的地址为`/turbine.stream`端点地址即集群监控地址

## `Hystrix`异常机制和处理

`Hystrix`的异常处理中有5中出错会被`fallback`所截获

- `FAILURE`执行失败抛出异常
- `TIMEOUT`执行超时
- `SHORT_CIRCUITED`断路器打开
- `THREAD_POOL_REJECTED`线程池拒绝
- `SEMAPHORE_REJECTED`信号量拒绝

抛出`HystrixBadRequestException`异常是不会触发`fallback`且不会被计数进入熔断

```java
public class FeignErrorDecoder implements feign.codec.ErrorDecoder {
    @Override
    public Exception decode(String methodKey, Response response) {
        try {
            if (response.status() >= 400 && response.status() <= 499) {
                String error = Util.toString(response.body().asReader());
                return new HystrixBadRequestException(error);
            }
        } catch (IOException e) {
            System.out.println(e);
        }
        return feign.FeignException.errorStatus(methodKey, response);
    }
}
```

上诉代码通过`ErrorDecoder`将400-500之间的错误封装成`HystrixBadRequestException`，不会触发熔断机制

## `Hystrix`配置说明

- 隔离策略【默认值:THREAD】
  - `hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds`
  - `hystrix.command.HystrixCommandKey.execution.isolation.thread.timeoutInMilliseconds`

- 超时时间【默认值:1000】

  - `hystrix.command.default.execution.isolation.thread.interruptOnTimeout`
  - `hystrix.command.HystrixCommandKey.execution.isolation.thread.interruptOnTimeout`

- 命令执行是否开启超时【默认值:true】

  - `hystrix.command.default.execution.timeout.enabled`
  - `hystrix.command.HystrixCommandKey.execution.timeout.enabled`

- 超时是否应中断执行操作【默认值:true】

  - `hystrix.command.default.execution.isolation.thread.interruptOnTimeout`
  - `hystrix.command.HystrixCommandKey.execution.isolation.thread.interruptOnTimeout`

- 信号量请求数，当设置为信号量隔离策略时设置最大允许的请求数【默认值:10】

  - `hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests`
  - `hystrix.command.HystrixCommandKey.execution.isolation.semaphore.maxConcurrentRequests`

- 设置失败百分比的阈值，如果比率超过这个值则打开断路器进入`fallback`逻辑【默认值:50】

  - `hystrix.command.default.circuitBreaker.errorThresholdPercentage`
  - `hystrix.command.HystrixCommandKey.circuitBreaker.errorThresholdPercentage`

- 强制打开断路器拒绝所有请求【默认值:false】

  - `hystrix.command.default.circuitBreaker.forceOpen`
  - `hystrix.command.HystrixCommandKey.circuitBreaker.forceOpen`

- 当为线程隔离时，线程池核心大小【默认值:10】

  - `hystrix.threadpool.default.coreSize`
  - `hystrix.threadpool.HystrixThreadPoolKey.coreSize`

- 设置`allowMaximumSizeToDivergeFromCoreSize`值为`true`时`maximumSize`才有作用【默认值:false】

  - `hystrix.threadpool.default.allowMaximumSizeToDivergeFromCoreSize`
  - `hystrix.threadpool.HystrixThreadPoolKey.allowMaximumSizeToDivergeFromCoreSize`

`HystrixCommandKey`如果不配置则默认为方法名，`Hystrix`默认超时时间为1秒，如果配置了`Ribbon`的超时时间，其超时时间也需要和`Ribbon`的时间配合使用，一般情况下`Ribbon`的超时时间应短于`Hystrix`超时时间

## `Hystrix`请求缓存

`Hystrix`的请求缓存是在同一个请求中进行的，在进行第一次调用结束后对结果缓存，然后接下来通参数的请求将会使用第一次的结果，缓存的生命周期只是在这一次请求中有效

- 类方式配置

  - 添加拦截器

    ```java
    public class CacheContextInterceptor implements HandlerInterceptor {
        private HystrixRequestContext context;
    
        @Override
        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
            context = HystrixRequestContext.initializeContext();
            return true;
        }
    
        @Override
        public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
    
        }
    
        @Override
        public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
            context.shutdown();
        }
    }
    ```

  - 配置拦截器

    ```java
    @Configuration
    public class CacheConfiguration {
        @Bean
        @ConditionalOnClass(Controller.class)
        public CacheContextInterceptor userContextInterceptor() {
            return new CacheContextInterceptor();
        }
    
        @Configuration
        @ConditionalOnClass(Controller.class)
        public class WebMvcConfig extends WebMvcConfigurerAdapter {
            @Autowired
            CacheContextInterceptor userContextInterceptor;
    
            @Override
            public void addInterceptors(InterceptorRegistry registry) {
                registry.addInterceptor(userContextInterceptor);
            }
        }
    }
    ```

  - 